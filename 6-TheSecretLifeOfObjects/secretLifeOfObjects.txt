Introduction
    In programming culture, we have a thing called 'OBJECT-ORIENTED PROGRAMMING', a set of techniques 
    that use objects (and related concepts) as the central principle of program organization.Though 
    no one really agrees on its precise definition, object-oriented programming has shaped the 
    design of many programming languages, including JavaScript. This chapter will describe the way 
    these ideas can be applied in JavaScript.


ENCAPSULATION
    Separating interface from implementation is a great idea. It is usually called "ENCAPSULATION".

    INTERFACE(BLUEPRINT FOR OBJECTS)
        In a program, various components interact through interfaces. These interfaces are sets of 
        functions or bindings that offer useful functionality at a higher level, concealing the exact 
        details of how they work.

        PUBLIC and PRIVATE
            Properties that are part of the interface are called 'PUBLIC'. The others, which outside 
            code should not be touching, are called 'PRIVATE'.

            Unlike many other programming languages, JavaScript does not currently have built-in support 
            for distinguishing public and private properties, preventing outside code from accessing private 
            ones. However, efforts are underway to incorporate this feature into the language in the future.

        JS PROGRAMMERS USING "PRIVATE" PROPERTY CONVENTIONS
            JavaScript programmers effectively employ private property conventions, even though the language 
            lacks built-in support for distinguishing public and private properties. They commonly describe 
            the available interface in documentation or comments, and often use an underscore (_) character 
            at the beginning of property names to signify their private nature.


THIS 

        When a function is invoked as a method, such as object.method(), the special binding called "this" 
        automatically refers to the object on which the method was called. This allows the method to easily 
        perform actions related to that specific object.
            Code-
                function speak(line) {
                    console.log(`The ${this.type} rabbit says '${line}'`);
                }

                let whiteRabbit = {type: "white", speak};
                let hungryRabbit = {type: "hungry", speak};

                whiteRabbit.speak("Oh my ears and whiskers, how late it's getting!");
                // → The white rabbit says 'Oh my ears and whiskers, how late it's getting!'
                
                hungryRabbit.speak("I could use a carrot right now.");
                // → The hungry rabbit says 'I could use a carrot right now.'

        call() METHOD 
            You can think of 'this' as an extra parameter that is passed in a different way. If you want 
            to pass it explicitly, you can use a function’s CALL() method, which takes the 'this' value as 
            its first argument and treats further arguments as normal parameters.
                Code1-
                    function speak(line) {
                        console.log(`The ${this.type} rabbit says '${line}'`);
                    }
                    speak.call(hungryRabbit, "Burp!");
                    // → The hungry rabbit says 'Burp!'

                Code2-
                    const person1 = {
                        name: "Alice",
                        greet: function(message) {
                            console.log(`${message}, ${this.name}!`);
                        }
                    };

                    const person2 = {
                        name: "Bob"
                    };

                    person1.greet("Hello"); // Output: Hello, Alice!

                    person1.greet.call(person2, "Hi"); // Output: Hi, Bob!

                In code2, we have two objects, person1 and person2. The person1 object has a greet() method 
                that logs a greeting message along with the name property of the object. By using call(), 
                we can invoke the greet() method of person1 with person2 as the 'thisValue', effectively 
                borrowing the greet() method and applying it to person2.



        USING 'THIS' WITH REGULAR FUNCTIONS
            In JavaScript, each function has its own "this" binding, and its value is determined by the 
            way the function is called. When using the "function" keyword to define a regular function, 
            you cannot directly refer to the "this" of the outer scope. The "this" inside the function 
            will have its own context, which might not be the same as the surrounding scope.

        USING 'THIS' WITH ARROW FUNCTIONS
            Arrow functions in JavaScript behave differently compared to regular functions when it comes 
            to the "this" keyword. Unlike regular functions, arrow functions do not have their own "this" 
            binding. Instead, they can access the "this" binding from the surrounding scope. This enables 
            us to reference "this" from within a local function, as demonstrated in the following code:
                Code-
                    function normalize() {
                        console.log(this.coords.map(n => n / this.length));
                    }
                    normalize.call({coords: [0, 2, 3], length: 5});
                    // → [0, 0.4, 0.6]

            In this example, using an arrow function as the argument for 'map' allows successful 
            referencing of "this". If a regular function had been used instead, the code would not 
            work as expected.
                Code-
                    function normalize() {
                        console.log(this.coords.map(function(n) { n / 2 }));
                    }
                    normalize.call({coords: [0, 2, 3], length: 5});
                    // → [undefined, undefined, undefined]


PROTOTYPES
        Take a look:
            let empty = {};
            console.log(empty.toString);
            // → function toString(){…}
            console.log(empty.toString());
            // → [object Object]

        Surprisingly, I obtained a property from an empty object. Seems like magic, doesn't it?

        However, it's not really magic. I've been holding back some information about how JavaScript 
        objects work. Besides their own set of properties, most objects also have a prototype. 

    "A 'PROTOTYPE' is another object that serves as a fallback source of properties." When an object 
    is asked for a property that it doesn't have, it searches for that property in its prototype. If 
    the prototype doesn't have it either, it will continue searching in the prototype's prototype, 
    and so on.

        So WHO is the prototype of that empty object? 
            It is the great ancestral prototype, the entity behind almost all objects, "Object.prototype".
                Code-
                    console.log(Object.getPrototypeOf({}) ==
                                Object.prototype);
                    // → true
                    console.log(Object.getPrototypeOf(Object.prototype));
                    // → null


        Object.getPrototypeOf()
            As you guess, Object.getPrototypeOf returns the prototype of an object.
            It is useful when you want to inspect the prototype chain of an object or when you need to 
            access properties or methods inherited from its(object's) prototype.



        THE Object.prototype
            The prototype relations of JavaScript objects form a tree-shaped structure, and at the root 
            of this structure sits Object.prototype. It provides a few methods that show up in all objects, 
            such as "toString", which converts an object to a string representation.

            Many objects don’t directly have Object.prototype as their prototype but instead have another 
            object that provides a different set of default properties. 
                FUNCTIONS derive from Function.prototype, 
                STRINGS derive from String.prototype, 
                NUMBERS derive from Number.prototype, and 
                ARRAYS derive from Array.prototype.

                    Code-
                        console.log(Object.getPrototypeOf(Math.max) ==  Function.prototype);
                        // → true
                        
                        console.log(Object.getPrototypeOf([]) ==  Array.prototype);
                        // → true

                        console.log(Object.getPrototypeOf("abcd") ==  String.prototype);
                        // → true

                        console.log(Object.getPrototypeOf(1287) ==  Number.prototype);
                        // → true

            Such a prototype object(Array.prototype and Function.prototype resp.) will itself have a 
            prototype, often Object.prototype, so that it still indirectly provides methods like toString.
                Code-
                    console.log(Object.getPrototypeOf(Array.prototype) == Object.prototype);
                    // → true

                    console.log(Object.getPrototypeOf(Function.prototype) == Object.prototype);
                    // → true

            LIST OF IMPORTANT PROTOTYPES 
                In JavaScript, several important prototypes are built-in and provide fundamental 
                functionality. These prototypes are part of the core JavaScript language and are 
                available for use in any JavaScript program. Here are some of the essential prototypes:

                    1.  Object.prototype:   This is the prototype for all objects in JavaScript. It provides 
                                            common properties and methods that are inherited by all objects, 
                                            such as toString(), hasOwnProperty(), and valueOf().

                    2.  Array.prototype:    This prototype is specific to arrays and provides methods for 
                                            manipulating arrays, such as push(), pop(), slice(), and forEach().

                    3.  String.prototype:   This prototype is specific to strings and provides methods for 
                                            working with strings, including charAt(), concat(), toUpperCase(), 
                                            and substring().

                    4.  Number.prototype:   This prototype is specific to numbers and provides methods for 
                                            working with numeric values, such as toFixed(), toPrecision(), 
                                            toString(), and mathematical methods like toFixed() and 
                                            toPrecision().

                    5.  Function.prototype: This prototype is specific to functions and provides methods 
                                            that can be accessed by any JavaScript function, including call(), 
                                            apply(), and bind(). These methods allow you to control the 
                                            function's execution context and arguments.

                    6.  Date.prototype:     This prototype is specific to dates and provides methods for 
                                            working with dates and times, such as getFullYear(), getMonth(), 
                                            getDate(), and toLocaleString().

                These are just a few examples of important prototypes in JavaScript. Each of these prototypes 
                contains a set of properties and methods that enable you to perform various operations and 
                manipulations within JavaScript. By leveraging these prototypes, you can extend and customize 
                the functionality of objects, arrays, strings, numbers, functions, and dates in your 
                JavaScript code.



        Object.create()
            You can use Object.create to create an object with a "SPECIFIC" prototype.
                Code-
                    let protoRabbit = {
                        speak(line) {
                            console.log(`The ${this.type} rabbit says '${line}'`);
                        }
                    };
                    let killerRabbit = Object.create(protoRabbit);
                    killerRabbit.type = "killer";
                    killerRabbit.speak("SKREEEE!");
                    // → The killer rabbit says 'SKREEEE!'

            A property like speak(line) in an object expression is a shorthand way of defining a method. 
            It creates a property called speak and gives it a function as its value.

            The “proto” rabbit acts as a container for the properties that are shared by all rabbits. An 
            individual rabbit object, like the "killerRabbit", contains properties that apply only to 
            itself— in this case its type—and derives shared properties from its prototype.


        hasOwnProperty()
            The hasOwnProperty() method is a built-in method in JavaScript that is used to determine if 
            an object has a specific property. It returns a boolean value indicating whether the object 
            has the property directly on itself (not inherited from its prototype chain).

            Here's an example that demonstrates the usage of hasOwnProperty():
                Code1-
                    const myObject = {
                        property1: 'value1',
                        property2: 'value2'
                    };

                    console.log(myObject.hasOwnProperty('property1')); // Output: true
                    console.log(myObject.hasOwnProperty('property2')); // Output: true
                    console.log(myObject.hasOwnProperty('property3')); // Output: false

            
            In above example, myObject is an object with properties property1 and property2. The 
            hasOwnProperty() method is called on myObject to check if it has the specified properties. 
            The method returns true if the object has the property directly, and false otherwise.
            It's important to note that hasOwnProperty() only checks for own properties and does not 
            look for properties inherited from the object's prototype chain.


                Code2-
                    console.log({x: 1}.hasOwnProperty("x"));
                    // → true
                    console.log({x: 1}.hasOwnProperty("toString"));
                    // → false

                
                Code3-
                    String.prototype.hasOwnProperty('substring');
                    // true
                    
                    String.prototype.hasOwnProperty('toString');
                    // true

                    "abcd".hasOwnProperty('substring');
                    // false

                    Array.prototype.hasOwnProperty('toString');
                    // true

                    [1,2,3].hasOwnProperty('toString');
                    // false


CLASSES
    JavaScript’s prototype system can be interpreted as a somewhat informal take on an object-oriented 
    concept(OOP) called CLASSES. 
    "In JavaScript, a class defines the structure or blueprint of an object type. It specifies the methods 
    and properties that the object will have. When an object is created based on a class, it is referred 
    to as an 'INSTANCE OF THE CLASS'."


    Prototypes are useful for defining properties for which all instances of a class share the same value, 
    such as methods. Properties that differ per instance, such as our rabbits’ type property, need to be 
    stored directly in the objects themselves.

    CONSTRUCTOR function 
        To create an instance of a class in JavaScript, you need to create an object that inherits from the 
        correct prototype. Additionally, you must ensure that the object itself has the necessary properties 
        required by instances of the class. This is where a CONSTRUCTOR function comes into play. 
        ""The CONSTRUCTOR function is responsible for setting up and initializing the object with the required 
        properties for instances of the class.""

            Code- // without using constructor
                let protoRabbit = {
                    speak(line) {
                        console.log(`The ${this.type} rabbit says '${line}'`);
                    }
                };
                
                function makeRabbit(type) {
                    let rabbit = Object.create(protoRabbit);
                    rabbit.type = type;
                    return rabbit;
                }

                let idiotRabbit = makeRabbit('idiot');
            
        THE 'NEW' KEYWORD
            JavaScript provides a way to make defining the above type of function easier. If you put the 
            keyword new in front of a function call, the function being called is treated as a constructor. 
            This means that an object with the right prototype is automatically created, bound to this in 
            the function, and returned at the end of the function.

        CONSTRUCTOR NAMING CONVENTION 
            By convention, the names of constructors are Capitalized so that they can easily be distinguished 
            from other functions.

        THE 'prototype' PROPERTY OF CONSTRUCTOR FUNCTION
            When constructing objects in JavaScript, the prototype object used can be found by accessing the 
            `PROTOTYPE` property of the constructor function. This `PROTOTYPE` property holds the prototype 
            object that will be used as a blueprint for creating new objects through the constructor function.
                    Code1-
                        function Rabbit(type) { // this constructor fnx creates an object with type property 
                                                // and return the object at the end of the function.
                            this.type = type;
                        }

                        Rabbit.prototype.speak = function(line) {
                            console.log(`The ${this.type} rabbit says '${line}'`);
                        };

                        let weirdRabbit = new Rabbit("weird"); // we get a new object
                        console.log(weirdRabbit.speak('Aham weirdosi'));
                        //-> The weird rabbit says 'Aham weirdosi'
                        console.log(Rabbit.prototype);
                        //-> Rabbit{speak: function(line){…}}

            Constructors, (including all functions) in JavaScript, automatically receive a property called `PROTOTYPE`. 
            By default, this property contains an empty object that inherits from `Object.prototype`. If you need, 
            you can overwrite the default object by assigning a new object to the `prototype` property. Alternatively, 
            you can add properties directly to the existing `prototype` object, as demonstrated in the example.
                    Code2-
                        // Constructor function
                        function Person(name) {
                            this.name = name;
                        }

                        console.log(Object.getPrototypeOf(Person.prototype) == Object.prototype) //-> true 

                        // Adding a method to the prototype object
                        Person.prototype.greet = function() {
                            console.log(`Hello, my name is ${this.name}`);
                        };

                        // Creating instances of the Person class
                        const person1 = new Person("Alice");
                        const person2 = new Person("Bob");

                        // Calling the method defined in the prototype
                        person1.greet(); // Output: Hello, my name is Alice
                        person2.greet(); // Output: Hello, my name is Bob

                In this example, the Person constructor function has a prototype property, which is initially an 
                empty object derived from Object.prototype. We add a greet method to the prototype object, which 
                can be accessed by instances of the Person class. The person1 and person2 objects are created 
                using the new keyword, and they inherit the greet method from the prototype object. Calling 
                person1.greet() and person2.greet() invokes the method and outputs the corresponding greetings.


        CONSTRUCTOR'S PROTOTYPE VS. OBJECT'S PROTOTYPE
            When we talk about prototypes in JavaScript, there are two important things to understand:

            1.  The prototype associated with a constructor: In JavaScript, constructors are special 
                                                             functions used to create objects. Each 
                                                             constructor has a property called prototype, 
                                                             which is like a blueprint or template. It 
                                                             defines the common properties and methods 
                                                             that will be shared by all instances created 
                                                             through that constructor.

            2.  The prototype of an object: Every object in JavaScript has a hidden property called 
                                            prototype. It represents the object's parent or the 
                                            prototype it inherits from. We can access this prototype 
                                            using the Object.getPrototypeOf() method.

            To make it clearer, here's an example:
                    Code1-
                        function Person(name) {
                            this.name = name;
                        }

                        Person.prototype.sayHello = function() {
                            console.log("Hello, my name is " + this.name);
                        };

                        const person1 = new Person("Alice");

                        console.log(Object.getPrototypeOf(person1) == Person.prototype); //-> true
                        console.log(Object.getPrototypeOf(Person) == Function.prototype); //-> true

            In this example, Person is a constructor function. It has a prototype property, which is an 
            object. The sayHello() method is added to Person.prototype, so all instances of Person will 
            inherit this method. Now, when we create an object using the Person constructor (person1 in 
            this case), it has a hidden property called [[Prototype]] that points to Person.prototype. 
            We can access this prototype using Object.getPrototypeOf(person1).

            So, to summarize:
                The actual prototype of a constructor is "Function.prototype" because constructors are 
                functions. The prototype property of a constructor holds the prototype used for 
                instances created through it. Objects created by a constructor have a hidden 
                [[Prototype]] property, which points to the constructor's prototype. Understanding 
                this distinction is important for working with prototypes and leveraging the 
                inheritance behavior in JavaScript. It allows us to define shared properties and 
                methods efficiently and create instances that inherit from a common prototype.


                
                    Code2-
                        function Rabbit(type) {
                            this.type = type;
                        }

                        Rabbit.prototype.speak = function(line) {
                            console.log(`The ${this.type} rabbit says '${line}'`);
                        };

                        let weirdRabbit = new Rabbit("Weird");

                        console.log(weirdRabbit.speak('Aham weirdosi'));
                        //-> The Weird rabbit says 'Aham weirdosi'

                        console.log(Object.getPrototypeOf(Rabbit) == Function.prototype);
                        // → true
                        
                        console.log(Object.getPrototypeOf(weirdRabbit) == Rabbit.prototype);
                        // → true


CLASS NOTATION
    Class declarations allow properties and methods to be added to the prototype.
        Code-
            class Rabbit {
                constructor(type) {
                    this.type = type;
                }

                speak(line) {
                    return `The ${this.type} rabbit says ${line}`;
                }
                
                hello =  'alpha'
                "bell" = 22
            }

            let killerRabbit = new Rabbit("killer");
            let blackRabbit = new Rabbit("black");
            console.log(killerRabbit.speak("I will kill you")); // The killer rabbit says I will kill you
            console.log(killerRabbit.hello); // alpha
            console.log(killerRabbit['bell']); // 22

    The "class keyword" starts a class declaration, which allows us to define a constructor and 
    a set of methods all in a single place. Any number of methods may be written inside the 
    declaration’s braces. The one named CONSTRUCTOR(in small letters) is treated specially. It provides
    the actual constructor function, which will be bound to the name Rabbit(name of the class). The 
    others are packaged into that constructor’s prototype. Thus, the above class declaration is 
    equivalent to the constructor definition from the previous section. This looks nicer.


    CLASSES AS EXPRESSION 
        In JavaScript, classes can be used as expressions, meaning they can be used in a context where a 
        value is expected. When a class is used as an expression, it doesn't create a binding or assign 
        the class to a variable. Instead, it produces the 'CONSTRUCTOR FUNCTION' itself as a value.
        This is the reason name of the class is used to reference the Constructor function.
            For example, consider the following code:
                const MyClass = class {
                    constructor() {
                        // Constructor logic here
                    }

                    method() {
                        // Method logic here
                    }
                };

                console.log(typeof MyClass); // Output: "function"

        In this code, the class is used as an expression, creating an anonymous class. The resulting value, 
        which is the constructor function, is assigned to the variable `MyClass`. However, note that the 
        class itself doesn't define a binding or a variable named `MyClass`. Instead, it produces the 
        constructor function as a value, which can then be used to create instances or access its methods.


OVERRIDING DERIVED PROPERTIES 
    When you add a property to an object, whether it is present in the prototype or not, the property is 
    added to the object itself. If there was already a property with the same name in the prototype, this 
    property will no longer affect the object, as it is now hidden behind the object’s own property.
       
        Code- 
            class Rabbit {
                constructor(type) {
                    this.type = type;
                }
                speak(line) {
                    return `The ${this.type} rabbit says '${line}'`;
                }
                
                hello =  'alpha';
                "bell" = 22;
                teeth = 'small';
            }

            let killerRabbit = new Rabbit("killer");
            let blackRabbit = new Rabbit("black");

            console.log(killerRabbit.teeth);
            // → small

            killerRabbit.teeth = "long, sharp, and bloody";
            console.log(killerRabbit.teeth);
            // → long, sharp, and bloody

            console.log(blackRabbit.teeth);
            // → small

            console.log(Rabbit.prototype.teeth);
            // → small


    Overriding properties that exist in a prototype can be a useful thing to do. As the 
    rabbit teeth example shows, overriding can be used to express exceptional properties 
    in instances of a more generic class of objects, while letting the nonexceptional 
    objects take a standard value from their prototype.


    OVERRIDING toString() METHOD IN ARRAYS 
        Overriding is also used to give the standard function and array prototypes a different 
        toString() method than the basic object prototype.
            Code-
                console.log(Array.prototype.toString);
                //-> [Function: toString]

                console.log(Object.prototype.toString);
                //-> [Function: toString]

                console.log( Array.prototype.toString == Object.prototype.toString );
                // → false

                console.log([1, 2].toString());
                // → 1,2

        Calling toString() on an array gives a result similar to calling .join(",") on it—it 
        puts commas between the values in the array. Directly calling Object.prototype.toString 
        with an array produces a different string. That function doesn’t know about arrays, so 
        it simply puts the word object and the name of the type between square brackets.
            Code-
                console.log(Object.prototype.toString.call([1, 2]));
                // → [object Array] 


MAPS
    A map (noun) is a data structure that associates values (the keys) with other values. 
    For example, you might want to map names to ages. It is possible to use objects for this.

    USING PLAIN OBJECTS AS MAP 
        Code-
            let ages = {
                Boris: 39,
                Liang: 22,
                Júlia: 62
            };

            console.log(`Júlia is ${ages["Júlia"]}`);
            // → Júlia is 62
            console.log("Is Jack's age known?", "Jack" in ages);
            // → Is Jack's age known? false
            console.log("Is toString's age known?", "toString" in ages);
            // → Is toString's age known? true

        Here, the object’s property names are the people’s names, and the property values are their ages. 
        But we certainly didn’t list anybody named toString in our map. Yet, because plain objects 
        derive from Object.prototype, it looks like the property is there.

        IT IS DANGEROUS!!
            1.  As such, using plain objects as maps is dangerous.
            
            2.  Object property names must be strings. If you need a map whose keys can’t easily be converted 
                to strings—such as objects—you cannot use an object as your map.


        HOW TO AVOID PROBLEMS??
            There are several possible ways to avoid this problem. First, it is possible to create 
            objects with no prototype. If you pass null to Object.create, the resulting object will 
            not derive from Object.prototype and can safely be used as a map.
            Code-
                console.log("toString" in Object.create({}));
                //-> true
        
                console.log("toString" in Object.create(null));
                // → false
    

    INBUILT MAP CLASS 
        JavaScript comes with a class called Map that is written for this exact purpose(using any type of keys). 
        It stores a mapping and allows any type of keys.
            Code-
                let ages = new Map();
                ages.set("Boris", 39);
                ages.set("Liang", 22);
                ages.set("Júlia", 62);

                console.log(`Júlia is ${ages.get("Júlia")}`);
                // → Júlia is 62
                console.log("Is Jack's age known?", ages.has("Jack"));
                // → Is Jack's age known? false
                console.log(ages.has("toString"));
                // → false

        Writing a data structure that can quickly update and search a large set of values isn’t easy, 
        but we don’t have to worry about that. Someone else did it for us, and we can go through this 
        simple interface to use their work.

        METHODS 
            The methods set, get, and has are part of the "INTERFACE" of the Map object.
            1.  set(key, value):    Adds a new key-value pair to the Map.
            2.         get(key):    Retrieves the value associated with a specific key.
            3.         has(key):    Returns a boolean indicating whether a key exists in the Map.
            4.      delete(key):    Removes a key-value pair from the Map based on the provided key.
            5.          clear():    Removes all key-value pairs from the Map.
            6.             size:    Returns the number of key-value pairs in the Map. 



POLYMORPHISM
    When you call the String function (which converts a value to a string) on an object, it will call 
    the toString() method on that object to try to create a meaningful string from it. I mentioned 
    that some of the standard prototypes define their own version of toString() so they can create a 
    string that contains more useful information than "[object Object]". You can also do that yourself.

        Code-
            class Rabbit {
                constructor(type) {
                    this.type = type;
                }
                speak(line) {
                    return `The ${this.type} rabbit says '${line}'`;
                }
                
                hello =  'alpha'
                "bell" = 22
            }
            Rabbit.prototype.toString = function() {
                return `a ${this.type} rabbit`;
            };

            console.log(String(blackRabbit));
            // → a black rabbit

    This is a simple instance of a powerful idea. When a piece of code(here it is String function) is 
    written to work with objects that have a certain interface/blueprint(in this case, a toString method) 
    — any kind of object that happens to support this interface/blueprint can be plugged into the code, 
    and it will just work.

    DEFINITION 
    This technique is called "POLYMORPHISM". POLYMORPHIC code can work with values of different shapes, 
    as long as they support the interface/blueprint it expects.

    for/of LOOP POLYMORPHISM
        I mentioned in Chapter 4 that a for/of loop can loop over several kinds of data structures. 
        This is another case of polymorphism—such loops expect the data structure to expose a 
        specific interface/blueprint, which arrays and strings do for for/of loop. And we can also add this 
        interface/blueprint to our own objects! But before we can do that, we need to know what symbols are.

    
SYMBOLS 
    Property names are usually strings, but they can also be symbols. SYMBOLS are values created with the 
    Symbol function. Unlike strings, newly created symbols are unique—you cannot create the same symbol twice.


    OPTIONAL DESCRIPTIVE LABELS FOR SYMBOLS 
        The string passed to Symbol() function provides a descriptive label for identification purposes, 
        but it doesn't have any inherent meaning beyond that. Multiple symbols can share the same string 
        label, but they are still distinct and separate entities.
            Example - 
                    const symbol1 = Symbol("mySymbol");
                    const symbol2 = Symbol("mySymbol");

                    console.log(String(symbol1)); // Output: "Symbol(mySymbol)"
                    console.log(String(symbol2)); // Output: "Symbol(mySymbol)"
                    console.log(symbol1 === symbol2); // Output: false (they are distinct symbols)


    'LEVERAGING SYMBOLS FOR INTERFACE DEFINITION AND COEXISTENCE WITH OTHER PROPERTIES'
        Being both unique and usable as property names makes symbols suitable for defining interfaces that can 
        peacefully live alongside other properties, no matter what their names are.


    It is possible to include symbol properties in object expressions and classes by using square brackets 
    around the property name. That causes the property name to be evaluated, much like the square bracket 
    property access notation, which allows us to refer to a binding that holds the symbol.
            CODE-
                const toStringSymbol = Symbol("toString");
                let stringObject = {
                    [toStringSymbol]() { return "a jute rope"; }
                };
                console.log(stringObject[toStringSymbol]());
                // → a jute rope

    SYMBOL REGISTRY
        The Symbol registry is an internal mechanism maintained by JavaScript runtime environments to generate 
        and manage unique symbols. It ensures that each symbol created using the Symbol() function has a 
        distinct internal identifier.

        INTERNAL IDENTIFIER 
            In JavaScript, internal identifiers, also known as internal slot names, are unique values used 
            by the JavaScript engine to track and manage various internal behaviors and state of objects 
            and other language constructs. These identifiers are not directly accessible or modifiable by 
            JavaScript code and are typically implemented as hidden properties or internal data structures 
            within the JavaScript engine.




THE ITERATOR INTERFACE 
    In JavaScript, Symbol.iterator is a well-known symbol that represents the default iterator for an object. 
    It is used to define the iterator behavior of an object, allowing it to be iterated over using the for...of 
    loop or other iterator-consuming methods.

    ITERATOR FUNCTION RETURNS ITERATOR OBJECT
        When an object has a property with the key Symbol.iterator and a function assigned to it, it becomes iterable. 
        The function, commonly referred to as the "ITERATOR FUNCTION", should return an "ITERATOR OBJECT". 


        PROPERTIES AND METHODS OF "ITERATOR OBJECT"
            1.  next() method - This iterator object must have a next() method that returns an object with 
                                value and done properties. 
            2.  value property -  The value property represents the next value in the iteration.
            
            3.  done  property -  The done property indicates whether there are more values to iterate over.

    Here's an example that demonstrates the usage of Symbol.iterator:

            Code1- 
                let okIterator = "PK"[Symbol.iterator]();
                console.log(okIterator.next());
                // → {value: "P", done: false}
                console.log(okIterator.next());
                // → {value: "K", done: false}
                console.log(okIterator.next());
                // → {value: undefined, done: true}

            Code2-  We have implemented iterator for our object replicating the internal working of for/of loop 
                    and Symbol.iterator 
                Refer here - 
                    D:\AngelaWebD\Books\EloquentJS\6-TheSecretLifeOfObjects\forOfLoop.js


    BUILDING AN ITERATOR INTERFACE 
        Refer to - 
            D:\AngelaWebD\Books\EloquentJS\6-TheSecretLifeOfObjects\matrix.js



GETTERS, SETTERS AND STATICS 
    In JavaScript, getters, setters, and static methods are features that enhance the behavior and functionality 
    of objects and classes. 
    Let's take a look at each of them:
        1. GETTERS: Getters are special methods that allow you to RETRIEVE the value of a property from an object 
                    dynamically. They provide a way to define custom behavior when accessing a property. 
                    Getters are defined using the "get" keyword followed by the property name.
                        Code-
                            const obj = {
                                firstName: 'Melissa',
                                lastName:  'Barrera',

                                get fullName() {
                                    return this.firstName + ' ' + this.lastName;
                                }
                            };

                            console.log(obj.fullName); // Output: 'Melissa Barrera'

        2. SETTERS: Setters are special methods that allow you to ASSIGN a value to a property of an object 
                    dynamically. They provide a way to define custom behavior when assigning a value to a 
                    property. Setters are defined using the "set" keyword followed by the property name.
                        Code-
                            const obj = {
                                firstName: '',
                                lastName: '',

                                set fullName(name) {
                                    [this.firstName, this.lastName] = name.split(' ');
                                }
                            };

                            obj.fullName = 'Alice Smith';
                            console.log(obj.firstName); // Output: Alice
                            console.log(obj.lastName); // Output: Smith


        3. STATIC METHODS:  Static methods are methods that are "ATTACHED TO A CLASS ITSELF", rather than to its 
                            instances. They are useful for defining utility functions or operations that don't 
                            require access to instance-specific data. Static methods are defined using the 
                            "static" keyword.
                                Code-
                                    class Circle {
                                        constructor(radius) {
                                            this.radius = radius;
                                        }

                                        // Instance method
                                        calculateArea() {
                                            return Math.PI * this.radius * this.radius;
                                        }

                                        // Static method
                                        static createFromDiameter(diameter) {
                                            const radius = diameter / 2;
                                            return new Circle(radius);
                                        }
                                    }

                                    // Using the static method
                                    const circle1 = Circle.createFromDiameter(10);
                                    console.log(circle1.calculateArea()); // Output: 78.53981633974483
                                /*  
                                    In this example, we have a Circle class with two methods: calculateArea() and 
                                    createFromDiameter(). 
                                    The calculateArea() method is an instance method that calculates the area of a 
                                    circle based on its radius. It is called on an instance of the Circle class and 
                                    depends on the specific radius property value of that instance. 
                                    The createFromDiameter() method is a static method that creates a new instance 
                                    of the Circle class based on the provided diameter. It calculates the radius 
                                    from the diameter and returns a new Circle object. Since it is a static method, 
                                    it can be called directly on the class itself without creating an instance.
                                */

    
    A 3-IN-1 EXAMPLE FOR GETTERS,SETTERS AND STATICS
        Code-
            class Temperature {
                constructor(celsius) {
                    this.celsius = celsius;
                }

                get fahrenheit() {
                    return this.celsius * 1.8 + 32;
                }

                set fahrenheit(value) {
                    this.celsius = (value - 32) / 1.8;
                }

                static fromFahrenheit(value) {
                    return new Temperature((value - 32) / 1.8);
                }
            }

            let temp = new Temperature(22);
            console.log(temp.fahrenheit); // → 71.6
            temp.fahrenheit = 86;
            console.log(temp.celsius);   // → 30
            let temp2 = Temperature.fromFahrenheit(104);
            console.log(temp2.celsius); //-> 40

        

INHERITANCE
        In JavaScript, "INHERITANCE" is achieved through prototype-based inheritance. Objects can inherit properties 
        and methods from other objects. The prototype system allows creating a new class similar to an existing class 
        but with the ability to redefine certain properties. The new class's prototype is based on the old class's 
        prototype but can introduce new method or property definitions. This inheritance concept is similar to 
        traditional object-oriented programming, where the new class inherits properties and behavior from the old 
        class, enabling it to extend and modify the existing functionality.

        Refer to this code for a proper working example- 
            D:\AngelaWebD\Books\EloquentJS\6-TheSecretLifeOfObjects\symmetricMatrixAndInheritance.js

    
        

        Inheritance is a concept in object-oriented programming that enables creating new data types with slight 
        modifications based on existing ones. It is considered fundamental along with encapsulation and polymorphism. 
        While encapsulation and polymorphism help separate code and improve program structure, inheritance has a 
        more controversial reputation.
        Unlike encapsulation and polymorphism, which promote code decoupling, inheritance inherently connects classes, 
        leading to increased complexity. When inheriting from a class, you often need to have a deeper understanding 
        of its inner workings compared to simply using it. While inheritance can be a useful tool in certain cases, 
        it shouldn't be the first approach to consider, and actively seeking opportunities to build class hierarchies 
        is generally discouraged.


    
    KEYWORDS AND CONCEPTS IN JAVASCRIPT INHERITANCE
        When working with inheritance in JavaScript, several keywords and concepts are essential. Here are the 
        key keywords and concepts related to inheritance in JavaScript:
            1. `class`: The `class` keyword is used to define a new class in JavaScript. It provides a cleaner 
                        syntax for creating objects and defining methods and properties within the class.

            2. `extends`: The `extends` keyword is used to create a subclass that inherits from a superclass. 
                          It establishes a hierarchical relationship between classes, allowing the subclass to 
                          inherit properties and methods from the superclass.

            3. `super`: The `super` keyword is used within a subclass constructor to call the constructor of the 
                        superclass. It allows the subclass to access and initialize properties defined in the 
                        superclass.

                        Super in ``class methods`` allows calling methods as they were defined in the superclass.

            4. `constructor`: The `constructor` method is a special method within a class that is executed when 
                              an instance of the class is created. It is used to initialize the object's 
                              properties and perform any necessary setup.

            5. `prototype`: The `prototype` property is an object that serves as a template for creating new 
                            instances of a class. It contains shared properties and methods that are inherited 
                            by all instances of the class.

            6. `Object.create()`: The `Object.create()` method is used to create a new object with a specified 
                                  prototype. It allows for explicit prototypal inheritance, where a new object 
                                  inherits properties and methods from an existing object.

            7. `this`:  The `this` keyword refers to the current object or context. It is used to access 
                        properties and methods within the class. When used inside a method, `this` typically 
                        refers to the instance of the class on which the method is being called.

            8. `instanceof`: The `instanceof` operator is used to determine whether an object is an instance of 
                             a particular class. It checks the prototype chain to see if the object inherits from 
                             the specified class or any of its ancestors.

            These are some of the important keywords and concepts used when working with inheritance in JavaScript. 
            Understanding their usage and behavior is crucial for implementing and leveraging inheritance 
            effectively in your JavaScript code.


INSTANCEOF() METHOD 
    The instanceof() operator in JavaScript is used to determine whether an object is an instance of a particular 
    class or constructor function. It checks the prototype chain of an object to see if the object inherits from 
    the specified class or any of its ancestors.
    The syntax of the instanceof operator is as follows:
        object instanceof constructor

    Here, object is the object instance that we want to check, and constructor is the class or constructor function 
    we want to compare it against.

    The instanceof operator returns a boolean value (true or false) depending on whether the object is an instance 
    of the specified class or not. If the object is an instance of the class or any of its parent classes, 
    it returns true; otherwise, it returns false.

    To understand how instanceof works, it checks if the prototype property of the constructor function 
    (constructor.prototype) is in the prototype chain of the object. It traverses up the prototype chain until it 
    reaches the top-level Object.prototype or until it finds a match with the specified constructor's prototype.
    Here's an example to illustrate the usage of the instanceof operator:

        D:\AngelaWebD\Books\EloquentJS\6-TheSecretLifeOfObjects\instanceOf.js