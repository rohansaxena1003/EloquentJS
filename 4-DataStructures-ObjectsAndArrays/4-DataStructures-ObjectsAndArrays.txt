INTRODUCTION
Numbers, Booleans, and Strings are the atoms that data structures 
are built from. Many types of information require more than one 
atom, though. 
    Data structures like Objects allow us to group values—including 
    other objects—to build more complex structures.


DATA SETS
JavaScript provides a data type specifically for storing sequences 
of values(called data sets). It is called an array and is written as a 
list of values between square brackets, separated by commas.
Example Code-
    let listOfNumbers = [2, 3, 5, 7, 11];
    console.log(listOfNumbers[2]);
    // → 5
    console.log(listOfNumbers[0]);
    // → 2
    console.log(listOfNumbers[4 - 1]);
    // → 7


PROPERTIES
Almost all JavaScript values have properties.The exceptions are NULL and UNDEFINED.

    2 WAYS TO ACCESS PROPERTIES IN JAVASCRIPT  
        In JavaScript, there are two main ways to access properties: 
            1. USING A DOT (.)
                When using the dot notation (value.x), the word after the dot 
                represents the literal name of the property. For example, if 
                you have an object called "value" and you want to access a 
                property named "x", you would use the dot notation: value.x.
            
            2. USING SQUARE BRACKETS ([]). 
                On the other hand, when using square brackets (value[x]), the expression inside 
                the brackets is evaluated to obtain the property name. This expression can be 
                any valid JavaScript expression. The result of the expression, converted to a 
                string, is used as the property name. For example, if you have a variable "x" 
                that stores the string "propertyName", you can access the property named 
                "propertyName" on the "value" object using square brackets: value[x].
                Code-
                    let value = { x: 3 };
                    value.x; // 3
                    value['x']; // 3
                    
                    let p ='x';
                    value[p]; // 3
        
        Both methods allow you to access a property on an object, but they differ 
        in how the property name is interpreted. 
        
        CONCLUSION
            In summary, the dot notation is used when you know the exact name 
            of the property you want to access, while square brackets allow 
            you to dynamically compute the property name using an 
            expression(usually a string).

        IMPORTANT
            Property names are strings. They can be any string, but 'THE DOT NOTATION 
            WORKS ONLY WITH NAMES THAT LOOK LIKE VALID BINDING NAMES(VARIABLE NAMES)'. 
            So if you want to access a property named 2 or John Doe, you 
            must use square brackets: value[2] or value["John Doe"].
            'READING A PROPERTY THAT DOESN’T EXIST WILL GIVE YOU THE VALUE UNDEFINED.'


METHODS 
Properties that contain functions are generally called METHODS of the value 
they belong to, as in “toUpperCase is a method of a string”.
    This example demonstrates two methods you can use to manipulate arrays:
    Code-
        let sequence = [1, 2, 3];
        sequence.push(4);
        sequence.push(5);
        console.log(sequence);
        // → [1, 2, 3, 4, 5]
        console.log(sequence.pop());
        // → 5
        console.log(sequence);
        // → [1, 2, 3, 4]


OBJECTS 
Values of the 'type' OBJECT are arbitrary collections of properties. 
    One way to create an object is by using curly braces as an expression.
    Code-
        let day1 = {
            squirrel: false,
            events: ["work", "touched tree", "pizza", "running"]
        };
        console.log(day1.squirrel);
        // → false
        console.log(day1.wolf);
        // → undefined
        day1.wolf = false;
        console.log(day1.wolf);
        // → false
        console.log(day1);
        //-> {squirrel: false, events: Array(4), wolf: false}
        /*  
            Inside the braces, there is a list of properties separated by commas. 
            Each property has a name followed by a colon and a value. When an object 
            is written over multiple lines, indenting it like in the example helps 
            with readability. 
        */

    Properties whose names aren’t valid binding(variable) names or valid numbers have 
    to be quoted.
        Code-
            let descriptions = {
                work: "Went to work",
                "touched tree": "Touched a tree",
                '2' : "hello two",
                2 : "hello 2"
            };
            console.log(descriptions["touched tree"]);
            //->'Touched a tree'
            console.log(description.'touched tree');
            //-> Uncaught SyntaxError: Unexpected string
            console.log(descriptions['2']);
            //-> 'hello 2'
            console.log(descriptions[2]);
            //-> 'hello 2'

    It is possible to assign a value to a property expression with the = operator. 
    This will replace the property’s value if it already existed or create a new 
    property on the object if it didn’t.
    Example is as follows-
        Code-
            let day1 = {
                squirrel: false,
                events: ["work", "touched tree", "pizza", "running"]
            };
            console.log(day1.wolf); // wolf property dne for day1 object.
            // → undefined
            day1.wolf = false; // = operator assigns the value to an unexisting property 
            console.log(day1.wolf);
            // → false
            day1.squirrel = true; // = operator RE-assigns the value to an existing property 
            console.log(day1.squirrel);
            // → true
            console.log(day1);
            //-> {squirrel: true, events: Array(4), wolf: false}

    OCTOPUS TENTACLES
    You may think of objects as octopuses with "any number of tentacles", each of 
    which has a name tattooed on it.

    "DELETE" OPERATOR
    The delete operator cuts off a tentacle from such an octopus. It is a UNARY 
    operator that, when applied to an object property, will remove the named 
    property from the object. This is not a common thing to do, but it is possible.
        Code-
            let anObject = {left: 1, right: 2};
            console.log(anObject.left);
            // → 1
            delete anObject.left;
            console.log(anObject.left);
            // → undefined
            console.log("left" in anObject);
            // → false
            console.log("right" in anObject);
            // → true

    "IN" OPERATOR
        The binary "in" operator, when applied to an array or an object property, 
        tells you whether that object has a property with that name. 
        The difference between "setting a property to undefined" and "actually 
        deleting it" is that, 
            1.in the "FIRST" case, the object still has the property (it just 
              doesn’t have a very interesting value), whereas 
            2.in the "SECOND" case the property is no longer present and "in" will 
              return 'false'.
            Code-
                let anObject = {
                    left: 1, 
                    right: 2, 
                    center: 3
                };
                console.log(anObject.left);
                // → 1

                anObject.right = undefined; /* Case 1 */
                console.log(anObject.right);
                //-> undefined
                console.log("right" in anObject); /* Case 1 */
                // → true

                delete anObject.left; /* Case 2 */
                console.log(anObject.left);
                // → undefined
                console.log("left" in anObject); /* Case 2 */
                // → false

                console.log("center" in anObject);
                //-> true

    Object.keys()
        To find out what properties an object has, you can use the Object.keys 
        function. You give it an object, and it returns an array of strings—
        the object’s property names.
        Code-
            console.log(Object.keys({x: 0, y: 0, z: 2}));
            // → ["x", "y", "z"]

    Object.assign()
        There’s an Object.assign function that copies all properties from one 
        object into another.
        Code-
            let objectA = {a: 1, b: 2};
            Object.assign(objectA, {b: 3, c: 4});
            console.log(objectA);
            // → {a: 1, b: 3, c: 4}

    Object.getOwnPropertyNames()
         It is a built-in method that allows you to retrieve an array of all properties 
         (including non-enumerable properties) defined directly on an object. It does 
         not include properties inherited from the object's prototype chain.
            Code-
                Object.getOwnPropertyNames(String);
                //-> [
                        'length',
                        'name',
                        'prototype',
                        'fromCharCode',
                        'fromCodePoint',
                        'raw'
                     ]

                Object.getOwnPropertyNames(Symbol);
                //-> [
                        'length',      'name',
                        'prototype',   'for',
                        'keyFor',      'asyncIterator',
                        'hasInstance', 'isConcatSpreadable',
                        'iterator',    'match',
                        'matchAll',    'replace',
                        'search',      'species',
                        'split',       'toPrimitive',
                        'toStringTag', 'unscopables'
                     ]


    ARRAYS AS OBJECTS
    Arrays, then, are just a "kind of object" specialized for storing sequences of 
    things. If you evaluate typeof [], it produces "object". "You can see them as 
    long, flat octopuses with all their tentacles in a neat row, labeled with numbers".


    MUTABILITY
        IMMUTABLE DATA TYPES 
            The types of values discussed in earlier chapters, such as numbers, strings, 
            and Booleans, are all immutable—it is impossible to change values of those 
            types. You can combine them and derive new values from them, but when you 
            take a specific string value, that value will always remain the same. The 
            text inside it cannot be changed. If you have a string that contains "cat", 
            it is not possible for other code to change a character in your string to 
            make it spell "rat".
            Code-
                let str = 'bat'
                str[1] = 'u';
                console.log(str)
                //-> 'bat' //string remains the same therefore it is immutable.

        OBJECTS ARE MUTABLE
            Objects work differently. You can change their properties, causing a single 
            object value to have different content at different times.
            let obj = {
                one: 1,
                two: 2
            };
            console.log(obj.one);
            //-> 1
            obj.one = 3;
            console.log(obj.one);
            //-> 3 // content of obj.one changes as objects are MUTABLE.   

    REFERENCE TO AN OBJECT
        With objects, there is a difference between having two references to the same 
        object and having two different objects that contain the same properties. 
        Consider the following code:
        Code-
            let object1 = {value: 10};
            let object2 = object1;
            let object3 = {value: 10};

            console.log(object1 == object2);
            // → true
            console.log(object1 == object3);
            // → false

            object1.value = 15;
            console.log(object2.value);
            // → 15
            console.log(object3.value);
            // → 10
        /* 
        The object1 and object2 bindings grasp the same object, which is why 
        changing object1 also changes the value of object2. They are said to 
        have the same identity. The binding object3 points to a different 
        object, which initially contains the same properties as object1 but 
        lives a separate life.
        */

    LET and CONST WITH OBJECTS
    Bindings can also be changeable or constant, but this is separate from the 
    way their values behave. Even though number values don’t change, you can 
    use a let binding to keep track of a changing number by changing the value 
    the binding points at. Similarly, though 
        'A CONST BINDING TO AN OBJECT CAN ITSELF NOT BE CHANGED AND WILL CONTINUE 
        TO POINT AT THE SAME OBJECT, THE CONTENTS OF THAT OBJECT MIGHT CHANGE.'
            Code-
                const score = {visitors: 0, home: 0};
                score.visitors = 1; // This is okay
                score = {visitors: 1, home: 1}; // This isn't allowed
    
    COMPARING DIFFERENT OBJECTS
        When you compare objects with JavaScript’s == operator, it compares by identity: 
        it will produce true only if both objects are precisely the same value. 
        Comparing different objects will return false, even if they have identical properties.
            Code-
                let object1 = {value: 10};
                let object2 = object1;
                let object3 = {value: 10};

                console.log(object1 == object2);
                // → true
                console.log(object1 == object3);
                // → false


ARRAYS AS OBJECTS
    Arrays, then, are just a "kind of object" specialized for storing sequences of 
    things. If you evaluate typeof [], it produces "object". "You can see them as 
    long, flat octopuses with all their tentacles in a neat row, labeled with numbers".


ARRAY LOOPS
    In the tableFor function, there’s a loop like this:
        Code-
            for (let i = 0; i < JOURNAL.length; i++) {
            let entry = JOURNAL[i];
            // Do something with entry
            }

    There is a simpler way to write such loops in modern JavaScript.
        Code-
            for (let entry of JOURNAL) {
                console.log(`${entry.events.length} events.`);
            }
        /*  
            When a for loop looks like this, with the word of after a variable 
            definition, it will loop over the elements of the value given after 
            of. This works not only for arrays but also for strings and some 
            other data structures.
        */

USEFUL ARRAY METHODS
    1.  shift() AND unshift()
            The methods for adding and removing things at the start of an 
            array are called unshift and shift respectively.
                unshift - adds task to start of queue;
                shift - removes value from start of queue;
                    Code-
                        let todoList = [];
                        function remember(task) {
                            todoList.push(task);
                        }
                        function getTask() {
                            return todoList.shift();
                        }
                        function rememberUrgently(task) {
                            todoList.unshift(task);
                        }
                    /*  
                    This program manages a queue of tasks. You add tasks to the end 
                        of the queue by calling remember("groceries"), and when you’re 
                        ready to do something, you call getTask() to get (and remove) 
                        the front item from the queue. The rememberUrgently function 
                        also adds a task but adds it to the front instead of the back 
                        of the queue.
                    */

    2.  indexOf() AND lastIndexOf()
            To search for a specific value, arrays provide an indexOf() method. The 
            method searches through the array from the start to the end and returns 
            the index at which the requested value was found— or -1 if it wasn’t found. 
            To search from the end instead of the start, there’s a similar method 
            called lastIndexOf().
                Code-
                    console.log([1, 2, 3, 2, 1].indexOf(2));
                    // → 1
                    console.log([1, 2, 3, 2, 1].lastIndexOf(2));
                    // → 3
                /*  
                    Both indexOf and lastIndexOf take an optional second argument that 
                    indicates where to start searching.
                */

    3.  slice()
            Another fundamental array method is slice, which takes start and end indices 
            and returns an array that has only the elements between them. 
                The start index = inclusive, 
                The end index   = exclusive.
                    Code-
                        console.log([0, 1, 2, 3, 4].slice(2, 4));
                        // → [2, 3]
                        console.log([0, 1, 2, 3, 4].slice(2));
                        // → [2, 3, 4]
                        console.log([0, 1, 2, 3, 4].slice());
                        // → [0,1,2, 3, 4]

                When the end index is not given, slice will take all of the elements after 
                the start index. You can also omit the start index to copy the entire array.

    4.  concat()
            The concat method can be used to glue arrays together to create a new array, 
            similar to what the + operator does for strings.

                The following example shows both concat and slice in action. It takes an 
                array and an index, and it returns a new array that is a copy of the 
                original array with the element at the given index removed.
                    Code1-
                        function remove(array, index) {
                            return array.slice(0, index).concat(array.slice(index + 1));
                        }
                        console.log(remove(["a", "b", "c", "d", "e"], 2));
                        // → ["a", "b", "d", "e"]
                    
                If you pass concat argument(s) that is not an array, that value(s) 
                will be added to the new array as if it were a one-element array.
                    Code2-
                        console.log([1,2,3].concat('alpha'));
                        //-> [1,2,3,'alpha'];
                        console.log([1,2,3].concat('alpha','beta'));
                        //-> [1,2,3,'alpha','beta'];

    5.  forEach() Method
        There is a built-in array method, forEach(), that provides something 
        like a for/of loop as a higher-order function.
            Code1-
                ["A", "B"].forEach(p => console.log(p));
                // → A
                // → B

            Code2-
                [1, 2].forEach(x => console.log(x+10));
                // → 11
                // → 12

    6.  filter() method
        Like forEach, filter() is a standard array method. filter() is a pure function.
        It does not modify the array it is given.It returns a new array.
            Code-
                let arr = [1,2,3,4,5,6,7];
                console.log(arr.filter(s => s%2==0));
                // → [2,4,6]

    7.  map() method
        Like filter(), map() is a standard array method. The map() method transforms an 
        array by applying a function to all of its elements and "building a new array" 
        from the returned values. The new array will have the same length as the input 
        array, but its content will have been mapped to a new form by the function.
            Code-
                let arr = [1,2,3,4,5,6,7];
                console.log(arr.map( n => n+20));
                // [21, 22, 23, 24, 25, 26, 27]

    8.  reduce() method
        Helps compute single value from an array.
        The higher-order operation that represents this pattern is called reduce 
        (sometimes also called fold). It builds a value by repeatedly taking a 
        single element from the array and combining it with the current value. 
        If your array contains at least one element, you are allowed to leave off the 
        start argument. The method will take the first element of the array as its 
        start value and start reducing at the second element.
            Code1-
                console.log([1, 2, 3, 4].reduce((a, b) => a + b) );
                // → 10

            
            Code2-
                let startVal = 12;
                console.log([1, 2, 3, 4].reduce((a, b) => a + b), startVal );
                // → 22

    9.  some() method 
        The some() method is an in-built higher-order function for arrays. It 
        takes a test function and tells you whether that function returns true 
        for any of the elements in the array.
            Code-
                console.log([1,2,3,4,5,6,7].some( n => n*3 === 15));
                // true 
            
            Code2-
                console.log([1,2,3,4,5,6,7].some( n => n*3 === 16));
                // false

    10. findIndex() ARRAY METHOD
        The above code uses another array method — findIndex(). This method is somewhat 
        like indexOf(), but instead of looking for a specific value, it finds the first 
        value for which the given function returns true. Like indexOf() , it returns -1 
        when no such element is found.
            Syntax-
                array.findIndex(callback(element, index, array), thisArg);
            
            Code-
                const fruits = ['apple', 'banana', 'mango', 'orange'];
                const index = fruits.findIndex((fruit) => fruit === 'mango');
                console.log(index); // Output: 2

    11. every() method 
        Analogous to the some method, arrays also have an every method. This one returns 
        true when the given function returns true for every element in the array. In a 
        way, some is a version of the || operator that acts on arrays, and every is like 
        the && operator.

        


STRINGS AND THEIR PROPERTIES 
    Unleash the Power of Strings: User-Defined Properties Not Allowed!
        We can read properties like length and toUpperCase from string values. But if 
        you try to add a new property, it doesn’t stick.
            Code-
            let kim = "Kim";
            kim.age = 88;
            console.log(kim.age);
            // → undefined

        Values of type string, number, and Boolean are not objects, and though 
        the language doesn’t complain if you try to set new properties on them, 
        it doesn’t actually store those properties. As mentioned earlier, such 
        values are immutable and cannot be changed.

    INBUILT PROPERTIES
        1.  slice() AND indexOf()
                They resemble the array methods of the same name.
                    Code-
                        console.log("coconuts".slice(4, 7));
                        // → nut
                        console.log("coconut".indexOf("u"));
                        // → 5
                
                One difference is that a string’s indexOf can search for a string 
                containing more than one character, whereas the corresponding 
                array method looks only for a single element.
                    Code-
                        console.log("one two three".indexOf("ee"));
                        // → 11
        

        2.  trim()
                The trim method removes whitespace (spaces, newlines, tabs, and 
                similar characters) from the start and end of a string.
                    Code-
                        console.log("  okay \n ".trim());
                        // → okay

        3.  padStart()
                The zeroPad function from the previous chapter also exists as a 
                method. It is called padStart and takes the desired length and 
                padding character as arguments.
                    Code-
                        console.log(String(6).padStart(3, "0"));
                        // → 006

        4.  split() and join()
                You can split a string on every occurrence of another string with 
                split and join it again with join.
                    Code-
                        let sentence = "Secretarybirds specialize in stomping";
                        let words = sentence.split(" ");
                        console.log(words);
                        // → ["Secretarybirds", "specialize", "in", "stomping"]
                        console.log(words.join(". "));
                        // → Secretarybirds. specialize. in. stomping

        5.  repeat()
                A string can be repeated with the repeat method, which creates a 
                new string containing multiple copies of the original string, 
                glued together.
                    Code-
                        console.log("LA".repeat(3));
                        // → LALALA


REST PARAMETERS
    In JavaScript, rest parameters are a way to allow a function to accept 
    an indefinite number of arguments as an array. The rest parameter 
    syntax is a set of three dots (...) followed by the name of the array 
    that will contain the remaining parameters. 
        For example:
            function max(...numbers) {
                let result = -Infinity;
                for (let number of numbers) {
                    if (number > result) result = number;
                }
                return result;
            }
            console.log(max(4, 1, 9, -2));
            // → 9

    Rest parameter must be last formal parameter in a function
        Code-
            function max(...numbers, x) {
                let result = -Infinity;
                for (let number of numbers) {
                    if (number > result) result = number;
                }
                return result;
            }
            max(4, 1, 9, -2);
            //-> Uncaught SyntaxError: Rest parameter must be last formal parameter

    Other parameters can come before the rest parameter.
        Code-
            function max(x,...numbers) {
                console.log(numbers+ " , " + x); //-> [1, 9, -2] , 4
                let result = -Infinity;
                for (let number of numbers) {
                    if (number > result) result = number;
                }
                return result;
            }
            console.log(max(4, 1, 9, -2));

    /*
        You can use a similar three-dot notation to call a function with an 
        array of arguments.
            Code-
                function max(x,...numbers) {
                    console.log(numbers+ " , " + x); //-> [1,7] , 5 
                    let result = -Infinity;
                    for (let number of numbers) {
                        if (number > result) result = number;
                    }
                    return result;
                }

                let numbers = [5, 1, 7];
                console.log(max(...numbers));
                // → 7

        console.log(max(...numbers)); “spreads” out the array into the function call, 
        passing its elements as separate arguments. It is possible to include an 
        array like that along with other arguments, as in max(9, ...numbers, 2).
            Code-
                function max(x,...numbers) {
                    console.log(numbers +" , " + x); //->  [4, 1, 2, 3, 4, 8] , 2
                    let result = -Infinity;
                    for (let number of numbers) {
                        if (number > result) result = number;
                    }
                    return result;
                }
                console.log(max(2,4,...[1,2,3,4],8)); //-> 8

    */

    /*
        Square bracket array notation similarly allows the triple-dot operator to 
        spread another array into the new array.
        Code-
            let words = ["never", "fully"];
            console.log(["will", ...words, "understand"]);
            // → ["will", "never", "fully", "understand"]
    */



THE MATH OBJECT
    The Math object is used as a container to group a bunch of related functionality. 
    There is only one Math object, and it is almost never useful as a value. Rather, 
    it provides a namespace so that all these functions and values do not have to be 
    global bindings.

    Having too many global bindings “pollutes” the namespace. The more names have 
    been taken, the more likely you are to accidentally overwrite the value of some 
    existing binding. For example, it’s not unlikely to want to name something max 
    in one of your programs. Since JavaScript’s built-in max function is tucked 
    safely inside the Math object, we don’t have to worry about overwriting it.

    Many languages will stop you, or at least warn you, when you are defining a 
    binding with a name that is already taken. JavaScript does this for bindings 
    you declared with let or const but—perversely—not for standard bindings nor 
    for bindings declared with var or function.

    Back to the Math object. If you need to do trigonometry, Math can help. 
    It contains cos (cosine), sin (sine), and tan (tangent), as well as their 
    inverse functions, acos, asin, and atan, respectively. The number π (pi)—
    or at least the closest approximation that fits in a JavaScript number—is 
    available as Math.PI. There is an old programming tradition of writing the 
    names of constant values in all caps.
    Code- 
        function randomPointOnCircle(radius) {
        let angle = Math.random() * 2 * Math.PI;
        return {x: radius * Math.cos(angle),
                y: radius * Math.sin(angle)};
        }
        console.log(randomPointOnCircle(2));
        // → {x: 0.3667, y: 1.966}


    Math.random() and PSEUDORANDOM numbers
        The previous example used Math.random(). This is a function that returns 
        a new pseudorandom number between zero (inclusive) and one (exclusive) 
        every time you call it.
        Code-
            console.log(Math.random());
            // → 0.36993729369714856
            console.log(Math.random());
            // → 0.727367032552138
            console.log(Math.random());
            // → 0.40180766698904335
        Though computers are deterministic machines—they always react the same way if 
        given the same input—it is possible to have them produce numbers that appear 
        random. To do that, the machine keeps some hidden value, and whenever you ask 
        for a new random number, it performs complicated computations on this hidden 
        value to create a new value. It stores a new value and returns some number 
        derived from it. That way, it can produce ever new, hard-to-predict numbers 
        in a way that seems random.

    Math.floor() , Math.ceil() , Math.round() and Math.abs()
        1.  If we want a whole random number instead of a fractional one, we can use Math.floor 
            (which rounds down to the nearest whole number) on the result of Math.random.
            Code-
                console.log(Math.floor(Math.random() * 10));
                // → 2
            Multiplying the random number by 10 gives us a number greater than or equal to 0 
            and below 10. Since Math.floor rounds down, this expression will produce, with 
            equal chance, any number from 0 through 9.

        2.  There are also the functions Math.ceil (for “ceiling”, which rounds up to a whole 
            number).
        
        3.  Math.round (to the nearest whole number), and 
        
        4.  Math.abs, which takes the absolute value of a number, meaning it negates negative 
            values but leaves positive ones as they are.


DESTRUCTURING

    Destructuring in JavaScript is a way to extract data from arrays and objects into variables. 
    This can be useful for making your code more concise and readable.

        ADVANTAGES
        Destructuring can be used to make your code more concise and readable. It can also 
        be used to make your code more flexible. 

    There are two types of destructuring in JavaScript: object destructuring and array destructuring.
        OBJECT DESTRUCTURING
                Object destructuring allows you to extract properties from an object into variables. 
                The syntax for object destructuring is:
                    Code-
                        const { property1, property2, ...rest } = obj;

                    The property1 and property2 variables will be assigned the values of the property1 
                    and property2 properties of the object obj. The rest variable will be an array 
                    containing the values of any remaining properties of the object obj.

                For example, the following code will extract the name, age and city properties from the 
                person object and assign them to the name, age and city variables:
                    Code-
                        const person = {
                            name: 'John',
                            age: 30,
                            city: 'New York',
                            looks: 'good',
                            height: 170,
                            sex: 'Male'
                        };

                        const { name, age, city, ...rest } = person;

                        console.log(name); // 'John'
                        console.log(age); // 30
                        console.log(city); // 'New York'
                        console.log(rest); // {looks: 'good', height: 170, sex: 'Male'}

                Destructuring can also be combined with default values:
                    Code-
                        const person = {
                            name: 'John',
                            age: 30
                        };

                        const { name, age, city = 'Mumbhai' } = person;

                        console.log(name); // 'John'
                        console.log(age); // 30
                        console.log(city); // 'Mumbhai'


        ARRAY DESTRUCTURING
                Array destructuring allows you to extract elements from an array into variables. 
                    The syntax for array destructuring is:
                        Code-
                            const [element1, element2, ...rest] = array;
                        The element1 and element2 variables will be assigned the values of the 
                        first two elements of the array array. The rest variable will be an array 
                        containing the values of any remaining elements of the array array.

                    For example, the following code will extract the first two elements of the numbers 
                    array and assign them to the firstNumber and secondNumber variables:
                        Code1-
                            let numbers = [1,2,3,4,5];
                            const [firstNumber, secondNumber] = numbers;
                            console.log(secondNumber + ", " +  firstNumber)
                            //-> 2, 1

                    The firstNumber and secondNumber variables will be assigned the values 
                    of the first and second index of the array. The rest variable will be 
                    an array containing the values of any remaining elements of the array.
                        Code2-
                            let numbers = [1,2,3,4,5];
                            const [firstNumber, secondNumber, ...rest] = numbers;
                            console.log(rest);
                        //-> [3,4,5] 


    JSON(JavaScript Object Notation)
        Serialization is the process of converting data into a flat representation. JSON 
        (JavaScript Object Notation) is a popular serialization format used for data storage and 
        communication on the web.

            JSON resembles JavaScript's syntax for arrays and objects but with a few limitations. 
                JSON LIMITATIONS
                    1.  Property names must be enclosed in double quotes, and 
                    2.  Only simple data expressions are allowed —  no function calls, 
                                                                    no bindings, 
                                                                    no computations. 
                    3.  JSON doesn't support comments.

        In summary, serialization simplifies data by converting it into a flat representation, and 
        JSON is a widely used format for storing and transmitting data on the web, adhering to a 
        specific syntax and limitations.

        JSON METHODS
        JavaScript provides two functions for working with JSON: JSON.stringify() and JSON.parse().
            1.  JSON.stringify() converts a JavaScript value into a JSON-encoded string.
            2.  JSON.parse() takes a JSON-encoded string and converts it back into the original 
                JavaScript value it represents.
            Code-
                let string = JSON.stringify({squirrel: false, events: ["weekend"]});
                console.log(string);
                // → {"squirrel":false,"events":["weekend"]}
                console.log(JSON.parse(string).events);
                // → ["weekend"]



















CURLY BRACES IN JAVASCRIPT 
In JavaScript, braces ({}) have two different meanings depending on 
their position in the code:

    1. As block delimiters: When braces are used at the start of a statement, 
                            they indicate the beginning and end of a block of 
                            statements. This is commonly seen in control flow 
                            structures like if statements, for loops, and 
                            function declarations. Here's an example:
                            Code-
                                if (condition) {
                                    // Code block executed when the condition is true
                                    statement1;
                                    statement2;
                                }
                            
                            In the above code, the braces define the block of 
                            code that should be executed when the condition is 
                            true. The statements inside the braces will be 
                            executed as a group.

    2. As object notation:  In any other position, braces are used to define an 
                            object literal. An object is a collection of key-value 
                            pairs, where the keys are strings and the values can 
                            be any valid JavaScript expression. Here's an example:
                            Code-
                                const myObject = {
                                    key1: value1,
                                    key2: value2,
                                };
                            
                            In the above code, the braces are used to define an 
                            object literal named myObject with two key-value pairs. 
                            The keys (key1 and key2) are strings, and the values 
                            (value1 and value2) can be any valid JavaScript expression.

    Fortunately, it is rarely necessary or useful to start a statement with 
    an object defined in braces. This means that the ambiguity between using 
    braces as block delimiters or object notation is not a significant 
    problem in practice.
    Some example codes-
        Code1-
            // Incorrect usage: Starting a statement with an object in braces
            { prop: value }; // SyntaxError: Unexpected token ':'

        Code2-
            // Object notation: Object defined as an expression
            const myObject = { prop: value };

            // Block delimiter: Braces used with control flow structures
            if (condition) {
                statement1;
                statement2;
            }

            // Function declaration: Braces used to define the function body
            function myFunction() {
                // Code block
            }

        By adhering to JS coding conventions and writing clean, well-structured 
        code, the potential ambiguity between block delimiters and object 
        notation can be minimized, making it easier to understand and 
        maintain JavaScript programs.